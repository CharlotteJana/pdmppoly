% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/polypdmp_class.R
\docType{class}
\name{polyPdmpModel-class}
\alias{polyPdmpModel-class}
\alias{polyPdmpModel}
\alias{polypdmpmodel}
\alias{polypdmp}
\alias{polyPdmp}
\title{Class polyPdmpModel}
\description{
An S4 class to represent polynomial piecewisc deterministic markov processes
(polynomial PDMPs). These processes are PDMPs with polynomial rate functions
and polynomial dynamics. This makes it possible to approximate the moments of
the process without the need of simulation, see \code{\link{momApp}}. On the
downside, simulations take much longer than simulations of the same PDMP 
represented as \code{pdmpModel}. \cr  
The class is based on the \code{\link[pdmpsim]{pdmpModel}} class of package
\pkg{pdmpsim} but introduces additional slots that replace the slots
\code{dynfunc} and \code{ratefunc}, namely \code{dynpolys}, \code{dynsprays},
\code{ratepolys} and \code{ratesprays}. Only slots \code{dynpolys} and
\code{ratepolys} have to be defined by the user. The other slots (including
the still existing \code{dynfunc} and \code{ratefunc}) will be set
automatically. To represent polynomials in \code{R}, package \pkg{spray} is
used, which stores the coefficient matrices of polynomials as sparse arrays.
}
\section{Slots}{

\describe{
\item{\code{dynpolys}}{an object of class \code{language}, more precisely a quoted
list. Every element of this list contains the ODE for one of the continous
variables. These ODEs are given as \code{spray} objects and can be defined
in two different ways. See section dynpolys for further information.}

\item{\code{ratepolys}}{an object of class \code{language}, more precisely a quoted
list.This list contains the rates for every jumptype. Every element is
itself a list, its length is determined by the number of different values
of the discrete variable (\code{length(discStates(obj)[[1]])}). See section
ratepolys for further information.}

\item{\code{dynsprays}}{a nested list of spray objects. This slot is generated
automatically out of slot \code{dynpolys}. Do not edit it by hand.}

\item{\code{ratesprays}}{a nested list of spray objects. This slot is generated
automatically out of slot \code{ratepolys}. Do not edit it by hand.}
}}

\note{
Currently, all methods only work for PDMPs with a single discrete
  variable. Some methods require the discrete variable to be the last
  entry in slot \code{init}. Note that it is always possible to redefine a 
  PDMP with multiple discrete variables in a way that only one discrete 
  variable is necessary.
}
\section{Ratepolys}{

Slot ratepolys is a quted list. The length of the list determines the number
of existing jumptypes (jumptypes are used in slot \code{jumpfunc} to
determine the next state the process jumps too). It contains the rates
determining the probability of a jump to be of type 1, 2, and so on. The
rates are polynomials that usually depend on the value of the discrete
variable at the time when the jump occurs. They are given as a list of spray
objects or numbers, for every possible discrete state separately (in the same
order as the states are given in slot \code{discStates}). \cr

For example, let's assume that we have three different jumptypes and a
discrete variable \code{d} that can take the values 0 or 1 (so slot
\code{discStates} would be defined as \code{list(d = 0:1)}). Then slot
\code{ratepolys} will be given as follows:
\preformatted{quote(list(
  list(rate of jtype 1 with d = 0, rate of jtype 1 with d = 1),
  list(rate of jtype 2 with d = 0, rate of jtype 2 with d = 1),
  list(rate of jtype 3 with d = 0, rate of jtype 3 with d = 1),
))}
Every \code{rate of jtype i with d = j} is a spray object, for example 
\code{linear(1:3)}.
}

\section{Dynpolys}{

Slot dynpolys is a quoted list. The length of the list equals the number of
continuous variables of the model. Every element contains the ODE for one of
the continuous variables, given in the same order as in slot \code{init} and
given as spray objects. \cr The ODEs usually depend on the discrete variable,
lets call it \code{d}. An example would be \eqn{\frac{df}{dt} = -3f}{df/dt =
-3f} if \eqn{d = 0} and  \eqn{\frac{df}{dt} = -3f + 1}{df/dt = -3f + 1} if
\eqn{d = 1}. Here, \code{f} is the only continous variable of the model.
Every ODE can be defined in two different ways:

\itemize{
\item variant 1: \cr
a list whose length equals the number of different states for d. Every entry is a 
polynomial with d taking a fixed value. The order of the entries corresponds
to the order of discrete states given in slot \code{discStates}.
\item variant 2: \cr
a list of two variables:
\itemize{
\item a variable \code{overall} which contains a polynomial that is independent 
of fixed values for \code{d} and is therefore the same for all states 
(attention: \code{overall} can contain \code{d} as a formal variable),
\item a variable \code{specific} which contains the rest of the term.
This is a list of the same form as in variant 1.
}}
In our example, we get
\itemize{
\item Variant 1: \cr
\code{quote(list(list(-3*lone(1,2), -3*lone(1,2) + 1)))}
\item Variant 2: \cr
\code{quote(list(list(overall = linear(c(-3, 0)), specific = list(0, 1))))}
\item Variant 2 with one formula: \cr
\code{quote(list(list(overall = linear(c(-3, 1))))}
}

The last variant is only possible, because in this example we have the
possiblity to write both ODEs in one formula: \eqn{\frac{df}{dt} = -3f +
d}{df/dt = -3f + d}.
}

\examples{
#### a simple PDMP ####

#------ pdmpModel version -----
simplePdmp <- new("pdmpModel",
                  descr = "A simple PDMP",
                  init = c(f = 0, d = 0),
                  discStates = list(d = c(-1, 0, 1)),
                  times = c(from = 0, to = 10, by = 0.01),
                  dynfunc = function(t, x, parms) c(x["d"], 0),
                  ratefunc = function(t, x, parms) c(1+x["d"], 1-x["d"]),
                  jumpfunc = function(t, x, parms, jtype){
                    c(0, switch(jtype, x["d"]-1, x["d"]+1))
                  }
)

#------ polyPdmpModel version -----
simplePoly <- new("polyPdmpModel",
                  descr = "polyModel with two jumptypes",
                  init = c(f = 0, d = 0),
                  times = c(from = 0, to = 10, by = 0.01),
                  discStates = list(d = -1:1),
                  dynpolys = quote(list(
                    list(overall = lone(2,2)) # variant 2
                  )),
                  ratepolys = quote(list(
                    list(0, 1, 2), # first jumptype
                    list(2, 1, 0)  # second jumptype
                  )),
                  jumpfunc = function(t, x, parms, jtype){
                    c(0, switch(jtype, x["d"]-1, x["d"]+1))
                  }
)

#------- comparison of the models --------------
identical(sim(simplePoly, outSlot = FALSE, seed = 5),
          sim(simplePdmp, outSlot = FALSE, seed = 5))

#### the toggleSwitch model ####

#------ pdmpModel version -----
genePdmpT <- new("pdmpModel", 
                 descr = "toggleswitch with two promotors",
                 parms = list(βA = 0.5, βB = 0.5, αA = 2, αB = 4, 
                               κ01A = 0.5, κ10A = 2, κ01B = 0.3, κ10B = 3),
                 init = c(ξA = 0.5, ξB = 0.5, θ = 4),
                 discStates = list(θ = 1:4),
                 dynfunc = function(t, x, parms) {
                   dξ <- with(as.list(c(x, parms)), 
                              c(-βA * ξA, -βB * ξB) + switch(θ, 
                                                              c(0, 0), 
                                                              c(αA, 0), 
                                                              c(0, αB), 
                                                              c(αA, αB)))
                   return(c(dξ, 0))
                 }, 
                 ratefunc = function(t, x, parms) {
                   return(with(as.list(c(x, parms)),
                               c(switch(θ, κ01B, κ01B, κ10B*ξA, κ10B*ξA),
                                 switch(θ, κ01A, κ10A*ξB, κ01A, κ10A*ξB))))
                 }, 
                 jumpfunc = function(t, x, parms, jtype) {
                   c(x[1:2], switch(jtype, 
                                    switch(x[3], 3, 4, 1, 2), 
                                    switch(x[3], 2, 1, 4, 3)))
                 }, 
                 times = c(from = 0, to = 100, by = 0.01), 
                 solver = "lsodar")

#------ polyPdmpModel version -----
library("spray")
genePolyT <- new("polyPdmpModel",
                 descr = "toggleswitch with two promotors (polynomial version)",
                 parms = list(βA = 0.5, βB = 0.5, αA = 2, αB = 4, 
                               κ01A = 0.5, κ10A = 2, κ01B = 0.3, κ10B = 3),
                 init = c(ξA = 0.5, ξB = 0.5, θ = 4), 
                 discStates = list(θ = 1:4),
                 dynpolys = quote(list(
                   list(overall = -βA*lone(1,3), specific = list(0, αA, 0, αA)),
                   list(overall = -βB*lone(2,3), specific = list(0, 0, αB, αB))
                 )), 
                 ratepolys = quote(list(  
                   list(κ01B, κ01B, κ10B*lone(1,3), κ10B*lone(1,3)),
                   list(κ01A, κ10A*lone(2,3), κ01A, κ10A*lone(2,3))
                 )),
                 jumpfunc = function(t, x, parms, jtype) {
                   c(x[1:2], switch(jtype, 
                                    switch(x[3], 3, 4, 1, 2), 
                                    switch(x[3], 2, 1, 4, 3)))
                 }, 
                 times = c(from = 0, to = 100, by = 0.01), 
                 solver = "lsodar")

#------- comparison of the models --------------
identical(sim(genePdmpT, outSlot = FALSE, seed = 10),
          sim(genePolyT, outSlot = FALSE, seed = 10))

data("toggleSwitch")
all.equal(sim(genePdmpT, outSlot = FALSE, seed = 20)[, c("ξA", "ξB")],
          sim(toggleSwitch, outSlot = FALSE, seed = 20)[, c("fA", "fB")],
          check.attributes = FALSE)
}
